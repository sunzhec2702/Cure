#include "rtc.h"

NVIC_InitTypeDef NVIC_InitStructure;

static calendar_obj current_calendar;

ErrorStatus rtc_set_time(calendar_obj cal)
{
	RTC_TimeTypeDef RTC_TimeTypeInitStructure;
	RTC_TimeTypeInitStructure.RTC_Hours = cal.hour;
	RTC_TimeTypeInitStructure.RTC_Minutes = cal.min;
	RTC_TimeTypeInitStructure.RTC_Seconds = cal.sec;
	RTC_TimeTypeInitStructure.RTC_H12 = RTC_H12_AM;
	return RTC_SetTime(RTC_Format_BIN, &RTC_TimeTypeInitStructure);
}

ErrorStatus rtc_set_date(calendar_obj cal)
{

	RTC_DateTypeDef RTC_DateTypeInitStructure;
	RTC_DateTypeInitStructure.RTC_Date = cal.date;
	RTC_DateTypeInitStructure.RTC_Month = cal.month;
	RTC_DateTypeInitStructure.RTC_WeekDay = cal.week;
	RTC_DateTypeInitStructure.RTC_Year = cal.year;
	return RTC_SetDate(RTC_Format_BIN, &RTC_DateTypeInitStructure);
}

ErrorStatus rtc_set_cal(calendar_obj cal)
{
	if (RTC_Set_Time(cal) == ERROR)
		return ERROR;
	if (RTC_Set_Date(cal) == ERROR)
		return ERROR;
	PWR_BackupAccessCmd(ENABLE);
	RTC_WriteBackupRegister(RTC_BKP_DR1, 0xDEADBEEF); // RTC has been set already
	PWR_BackupAccessCmd(DISABLE);
	return SUCCESS;
}

ErrorStatus update_current_calendar()
{
	RTC_DateTypeDef RTC_DateTypeInitStructure;
	RTC_GetDate(RTC_Format_BIN, &RTC_DateTypeInitStructure);
	current_calendar.date = RTC_DateTypeInitStructure.RTC_Date;
	current_calendar.month = RTC_DateTypeInitStructure.RTC_Month;
	current_calendar.week = RTC_DateTypeInitStructure.RTC_WeekDay;
	current_calendar.year = RTC_DateTypeInitStructure.RTC_Year;
	RTC_GsetTime(RTC_Format_BIN, &RTC_DateTypeInitStructure);
	current_calendar.hour = RTC_DateTypeInitStructure.RTC_Hours;
	current_calendar.min = RTC_DateTypeInitStructure.RTC_Minutes;
	current_calendar.sec = RTC_DateTypeInitStructure.RTC_Seconds;
}

calendar_obj* get_current_calendar()
{
	update_current_calendar();
	return &current_calendar;
}

u8 is_calendar_initialized()
{
	if (RTC_ReadBackupRegister(BTC_BKP_DR1) == 0xDEADBEEF)
		return TRUE;
	else
		return FALSE;
}

//RTC初始化
//返回值:0,初始化成功;
//       1,LSE开启失败;
//       2,进入初始化模式失败;
u8 RTC_Init(void)
{
	RTC_InitTypeDef RTC_InitStructure;
	u16 retry = 0X1FFF;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); //使能PWR时钟
	PWR_BackupAccessCmd(ENABLE);						//使能后备寄存器访问
	if (RTC_ReadBackupRegister(RTC_BKP_DR0) != 0x5050)
	{
		RCC_LSEConfig(RCC_LSE_ON);							//LSE 开启
		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) //检查指定的RCC标志位设置与否,等待低速晶振就绪
		{
			retry++;
			delay_ms(10);
		}
		if (retry == 0)
			return 1; //LSE 开启失败.
		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE); //设置RTC时钟(RTCCLK),选择LSE作为RTC时钟
		RCC_RTCCLKCmd(ENABLE);					//使能RTC时钟
		RTC_InitStructure.RTC_AsynchPrediv = 0x7F;			  //RTC异步分频系数(1~0X7F)
		RTC_InitStructure.RTC_SynchPrediv = 0xFF;			  //RTC同步分频系数(0~7FFF)
		RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24; //RTC设置为,24小时格式
		RTC_Init(&RTC_InitStructure);
		RTC_WriteBackupRegister(RTC_BKP_DR0, 0x5050); //标记已经初始化过了
	} 
	return 0;
}

//设置闹钟时间(按星期闹铃,24小时制)
//week:星期几(1~7) @ref  RTC_Alarm_Definitions
//hour,min,sec:小时,分钟,秒钟
void RTC_Set_AlarmA(u8 week, u8 hour, u8 min, u8 sec)
{
	EXTI_InitTypeDef EXTI_InitStructure;
	RTC_AlarmTypeDef RTC_AlarmTypeInitStructure;
	RTC_TimeTypeDef RTC_TimeTypeInitStructure;

	RTC_AlarmCmd(RTC_Alarm_A, DISABLE); //关闭闹钟A

	RTC_TimeTypeInitStructure.RTC_Hours = hour;  //小时
	RTC_TimeTypeInitStructure.RTC_Minutes = min; //分钟
	RTC_TimeTypeInitStructure.RTC_Seconds = sec; //秒
	RTC_TimeTypeInitStructure.RTC_H12 = RTC_H12_AM;

	RTC_AlarmTypeInitStructure.RTC_AlarmDateWeekDay = week;								  //星期
	RTC_AlarmTypeInitStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_WeekDay; //按星期闹
	RTC_AlarmTypeInitStructure.RTC_AlarmMask = RTC_AlarmMask_None;						  //精确匹配星期，时分秒
	RTC_AlarmTypeInitStructure.RTC_AlarmTime = RTC_TimeTypeInitStructure;
	RTC_SetAlarm(RTC_Format_BIN, RTC_Alarm_A, &RTC_AlarmTypeInitStructure);

	RTC_ClearITPendingBit(RTC_IT_ALRA);  //清除RTC闹钟A的标志
	EXTI_ClearITPendingBit(EXTI_Line17); //清除LINE17上的中断标志位

	RTC_ITConfig(RTC_IT_ALRA, ENABLE); //开启闹钟A中断
	RTC_AlarmCmd(RTC_Alarm_A, ENABLE); //开启闹钟A

	EXTI_InitStructure.EXTI_Line = EXTI_Line17;			   //LINE17
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	//中断事件
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; //上升沿触发
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;			   //使能LINE17
	EXTI_Init(&EXTI_InitStructure);						   //配置

	NVIC_InitStructure.NVIC_IRQChannel = RTC_Alarm_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级1
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;		 //子优先级2
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				 //使能外部中断通道
	NVIC_Init(&NVIC_InitStructure);								 //配置
}

//周期性唤醒定时器设置
/*wksel:  @ref RTC_Wakeup_Timer_Definitions
#define RTC_WakeUpClock_RTCCLK_Div16        ((uint32_t)0x00000000)
#define RTC_WakeUpClock_RTCCLK_Div8         ((uint32_t)0x00000001)
#define RTC_WakeUpClock_RTCCLK_Div4         ((uint32_t)0x00000002)
#define RTC_WakeUpClock_RTCCLK_Div2         ((uint32_t)0x00000003)
#define RTC_WakeUpClock_CK_SPRE_16bits      ((uint32_t)0x00000004)
#define RTC_WakeUpClock_CK_SPRE_17bits      ((uint32_t)0x00000006)
*/
//cnt:自动重装载值.减到0,产生中断.
void RTC_Set_WakeUp(u32 wksel, u16 cnt)
{
	EXTI_InitTypeDef EXTI_InitStructure;

	RTC_WakeUpCmd(DISABLE); //关闭WAKE UP

	RTC_WakeUpClockConfig(wksel); //唤醒时钟选择

	RTC_SetWakeUpCounter(cnt); //设置WAKE UP自动重装载寄存器

	RTC_ClearITPendingBit(RTC_IT_WUT);   //清除RTC WAKE UP的标志
	EXTI_ClearITPendingBit(EXTI_Line22); //清除LINE22上的中断标志位

	RTC_ITConfig(RTC_IT_WUT, ENABLE); //开启WAKE UP 定时器中断
	RTC_WakeUpCmd(ENABLE);			  //开启WAKE UP 定时器　

	EXTI_InitStructure.EXTI_Line = EXTI_Line22;			   //LINE22
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;	//中断事件
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; //上升沿触发
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;			   //使能LINE22
	EXTI_Init(&EXTI_InitStructure);						   //配置

	NVIC_InitStructure.NVIC_IRQChannel = RTC_WKUP_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02; //抢占优先级1
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x02;		 //子优先级2
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;				 //使能外部中断通道
	NVIC_Init(&NVIC_InitStructure);								 //配置
}

u8 Is_Leap_Year(u16 year)
{
	if (year % 4 == 0) //必须能被4整除
	{
		if (year % 100 == 0)
		{
			if (year % 400 == 0)
				return 1; //如果以00结尾,还要能被400整除
			else
				return 0;
		}
		else
			return 1;
	}
	else
		return 0;
}

//获得现在是星期几
//功能描述:输入公历日期得到星期(只允许1901-2099年)
//输入参数：公历年月日
//返回值：星期号
u8 RTC_Get_Week(u16 year, u8 month, u8 day)
{
	u16 temp2;
	u8 yearH, yearL;

	yearH = year / 100;
	yearL = year % 100;
	// 如果为21世纪,年份数加100
	if (yearH > 19)
		yearL += 100;
	// 所过闰年数只算1900年之后的
	temp2 = yearL + yearL / 4;
	temp2 = temp2 % 7;
	temp2 = temp2 + day + table_week[month - 1];
	if (yearL % 4 == 0 && month < 3)
		temp2--;
	return (temp2 % 7);
}
